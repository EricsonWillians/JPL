; ============================================================
; Lilith Programming Language Grammar (Fully Enhanced)
; ============================================================
; 
; Core design:
;   • Every token is a punctuation sequence.
;   • Paired tokens are chosen for maximal symmetry.
;   • Reserved tokens (e.g. "{[", "]}", etc.) must not appear within identifiers.
;
; This grammar now supports:
;   - Collections (lists, tuples, dictionaries, sets) with comprehensions.
;   - Synchronous and asynchronous function definitions with type annotations.
;   - Return and yield statements.
;   - Exception handling (try, except, finally).
;   - Loop control (break and continue).
;   - Pattern matching (match–case with simple destructuring).
;   - Asynchronous constructs (await expressions).
;   - Macros for metaprogramming.
;   - Comments (lexer-level: “/* … */”).
; ============================================================

<program>      ::= "{[" <stmt_list> "]}"

<stmt_list>    ::= <stmt> { "][" <stmt> }

<stmt>         ::= <simple_stmt>
                 | <compound_stmt>

<simple_stmt>  ::= <assign_stmt>
                 | <expr_stmt>
                 | <import_stmt>
                 | <return_stmt>
                 | <yield_stmt>
                 | <break_stmt>
                 | <continue_stmt>
                 | <macro_def>

<expr_stmt>    ::= <expr>

<assign_stmt>  ::= <id> "[=]" <expr>

; ------------------------------------------------------------
; Import Statements
; ------------------------------------------------------------
<import_stmt>  ::= "<{" <import_list> "}>"
<import_list>  ::= <module> { ",," <module> }
<module>       ::= <id> { ".." <id> }     ; Hierarchical module names via ".."

; ------------------------------------------------------------
; Return and Yield Statements
; ------------------------------------------------------------
<return_stmt>  ::= ")-" [ <expr> ] "-("         ; “return” (optionally with an expression)
<yield_stmt>   ::= ")-?" [ <expr> ] "?-("       ; “yield” (for generators)

; ------------------------------------------------------------
; Loop Control
; ------------------------------------------------------------
<break_stmt>   ::= "]-!"                      ; “break”
<continue_stmt>::= "]-?"                      ; “continue”

; ------------------------------------------------------------
; Exception Handling
; ------------------------------------------------------------
<try_stmt>     ::= "{?" <block> { <except_clause> } [ <finally_clause> ] "?}"
<except_clause>::= "[!" [ <exception_target> ] "[/]" <block> "!]"
<exception_target> ::= <id>                  ; (Optionally a pattern could be allowed here)
<finally_clause>  ::= "[:~" <block> "~:]"

; ------------------------------------------------------------
; Pattern Matching (Match–Case)
; ------------------------------------------------------------
<match_stmt>   ::= "(-<" <expr> ">-)" { <case_block> }
<case_block>   ::= "[<" <pattern> ">]" "[[" <stmt_list> "]]"

<pattern>      ::= <literal>
                 | <id>
                 | "(<" <pattern_list> ">)"    ; Tuple–pattern
<pattern_list> ::= <pattern> { ",," <pattern> }

<literal>      ::= <number> | <string>

; ------------------------------------------------------------
; Function Definitions with Type Annotations
; ------------------------------------------------------------
<func_def>     ::= "(|" <id> <param_block> [ "->" <type_expr> ] "[[" <stmt_list> "]]" "|)"
<async_func_def> ::= "(|" "~" <id> <param_block> [ "->" <type_expr> ] "[[" <stmt_list> "]]" "|)"
; (Async functions are marked by a "~" immediately after "(|".)

<param_block>  ::= "((" [ <param_list> ] "))"
<param_list>   ::= <param> { ",," <param> }
<param>        ::= <id> [ "(:)" <type_expr> ]       ; Optional type annotation
<type_expr>    ::= <expr>                           ; Types are expressed as expressions

; ------------------------------------------------------------
; Macros for Metaprogramming
; ------------------------------------------------------------
<macro_def>    ::= "<%|" <id> <param_block> "[[" <stmt_list> "]]" "|%>"
<macro_call>   ::= <id> <arg_block>                 ; Macros are invoked like functions

; ------------------------------------------------------------
; Asynchronous Constructs
; ------------------------------------------------------------
<await_expr>   ::= "~(" <expr> ")~"                ; Await expression

; ------------------------------------------------------------
; Compound Statements (Control Flow)
; ------------------------------------------------------------
<compound_stmt> ::= <if_stmt>
                  | <loop_stmt>
                  | <try_stmt>
                  | <match_stmt>
                  | <func_def>
                  | <async_func_def>
                  | <class_def>
                  | <block>

<block>        ::= "[[" <stmt_list> "]]"

; ------------------------------------------------------------
; Conditionals
; ------------------------------------------------------------
<if_stmt>      ::= "[?" <condition> <then_block> [ <else_clause> ] "?]"
<condition>    ::= "((" <expr> "))"
<then_block>   ::= "[[" <stmt_list> "]]"
<else_clause>  ::= ":|:" "[[" <stmt_list> "]]"

; ------------------------------------------------------------
; Loops (WHILE–style)
; ------------------------------------------------------------
<loop_stmt>    ::= "<+" "((" <expr> "))" "[[" <stmt_list> "]]" "+>"

; ------------------------------------------------------------
; Class Definitions (with Inheritance)
; ------------------------------------------------------------
<class_def>    ::= "{|" <id> [ <inheritance_list> ] "[[" <stmt_list> "]]" "|}"
<inheritance_list> ::= "([:" <inherit_list> ":])"
<inherit_list> ::= <expr> { ",," <expr> }

; ------------------------------------------------------------
; Expressions
; ------------------------------------------------------------
<expr>         ::= <cond_expr>
                 | <arith_expr> { ( "++" | "--" ) <arith_expr> }

<cond_expr>    ::= "[?" "((" <expr> "))" "[(" <expr> ")]" [ ":|:" "[(" <expr> ")]" ] "?]"

; ------------------------------------------------------------
; Arithmetic Expressions
; ------------------------------------------------------------
<arith_expr>   ::= <term> { ( "**" | "//" ) <term> }

<term>         ::= [ <unary_op> ] <primary>
<unary_op>     ::= ":-:"      ; Palindromic unary operator

; ------------------------------------------------------------
; Primary Expressions
; ------------------------------------------------------------
<primary>      ::= <number>
                 | <string>
                 | <list_literal>
                 | <tuple_literal>
                 | <dict_literal>
                 | <set_literal>
                 | <call_expr>
                 | <lambda_expr>
                 | <await_expr>
                 | <macro_call>
                 | <id>
                 | "((" <expr> "))"    ; Explicit grouping

<call_expr>    ::= <id> <arg_block>
<arg_block>    ::= "((" [ <arg_list> ] "))"
<arg_list>     ::= <expr> { ",," <expr> }

<lambda_expr>  ::= "(:<" [ <param_block> ] <lambda_body> ">:)"
<lambda_body>  ::= <expr>
                 | "[[" <stmt_list> "]]"

; ------------------------------------------------------------
; Collection Literals & Their Comprehensions
; ------------------------------------------------------------

; --- List Literals ---
<list_literal>  ::= "[<" <list_content> ">]"
<list_content>  ::= <list_expr> | <list_comp>
<list_expr>     ::= [ <expr> { ",," <expr> } ]    ; May be empty.
<list_comp>     ::= <expr> <comp_clauses>

; --- Tuple Literals ---
<tuple_literal> ::= "(<" <tuple_content> ">)"
<tuple_content> ::= <tuple_expr> | <tuple_comp>
<tuple_expr>    ::= [ <expr> { ",," <expr> } ]
<tuple_comp>    ::= <expr> <comp_clauses>

; --- Dictionary Literals ---
<dict_literal>  ::= "{<" <dict_content> ">}"
<dict_content>  ::= <dict_expr> | <dict_comp>
<dict_expr>     ::= [ <pair> { ",," <pair> } ]
<pair>          ::= <expr> "[:]" <expr>
<dict_comp>     ::= <pair> <comp_clauses>

; --- Set Literals ---
<set_literal>   ::= "[{" <set_content> "}]"
<set_content>   ::= <set_expr> | <set_comp>
<set_expr>      ::= [ <expr> { ",," <expr> } ]
<set_comp>      ::= <expr> <comp_clauses>

; ------------------------------------------------------------
; Comprehension Clauses (for all collection types)
; ------------------------------------------------------------
<comp_clauses>  ::= <comp_clause> { <comp_clause> }
<comp_clause>   ::= <for_clause> | <if_clause>

<for_clause>    ::= "[:<" <iter_target> "[%]" <expr> ">:]"
<iter_target>   ::= <id> { ",," <id> }
<if_clause>     ::= "[?:" <expr> ":?]"

; ------------------------------------------------------------
; Literals
; ------------------------------------------------------------
<number>       ::= <digit> { <digit> }
<digit>        ::= "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"

<string>       ::= "\"" { <char> } "\""
<char>         ::= any ASCII character except "\""

; ------------------------------------------------------------
; Identifiers
; ------------------------------------------------------------
<id>           ::= <sym> { <sym> }
<sym>          ::= "!" | "@" | "#" | "$" | "%" | "^" | "&" | "*" 
                 | "_" | "=" | "+" | "-" | "/" | "?" | ":"

; ============================================================
; Comments (handled at the lexer level)
; ============================================================
; A comment begins with "/*" and ends with "*/".
; ============================================================
